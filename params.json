{
  "name": "Bluckdb",
  "tagline": "A Key/Value store implementation using Golang",
  "body": "# Bluckdb\r\n\r\n[![Build Status](https://travis-ci.org/BenJoyenConseil/bluckdb.svg?branch=master)](https://travis-ci.org/BenJoyenConseil/bluckdb) [![Stories in Ready](https://badge.waffle.io/BenJoyenConseil/bluckdb.png?label=ready&title=Ready)](https://waffle.io/BenJoyenConseil/bluckdb) [![Go Report Card](https://goreportcard.com/badge/github.com/BenJoyenConseil/bluckdb)](https://goreportcard.com/report/github.com/BenJoyenConseil/bluckdb) [![GoDoc](https://godoc.org/github.com/BenJoyenConseil/bluckdb?status.svg)](https://godoc.org/github.com/BenJoyenConseil/bluckdb)\r\n\r\nIt is a Key/Value store that implements bucketing based on [extendible hashing](https://en.wikipedia.org/wiki/Extendible_hashing)\r\n\r\nThe ``server.go`` file is a simple http server that answers on the 2233 port.\r\n\r\n\r\nThere are 3 endpoints :\r\n\r\n    curl -XGET http://hostname:2233/?id=<key>\r\n    curl -XPUT -d 'value' http://hostname:2233/?id=<key>\r\n    curl -XGET http://hostname:2233/meta\r\n    curl -XGET http://hostname:2233/debug?page_id=<id_of_the_page_to_display>\r\n\r\n\r\n## the goal\r\n\r\nThe goal of this project is to explore and to reinvent the wheel of well known, state of the art, algorithms and data structures.\r\nFor experimental and learning purpose only, not production ready.\r\n\r\n\r\n## design\r\n\r\nA Directory is a table of buckets called \"Page\". \r\n\r\nA Page is a byte array of 4096 bytes length, append only. \r\nTrailer : It stores actual usage of the Page at 4094 bytes (unint16), and local depth at 9092 bytes (unint16)\r\n\r\nA Record is a byte array with a key, a value and the headers :\r\n \r\n    type Record interface {\r\n        Key() []byte\r\n        Val() []byte\r\n        KeyLen() uint16\r\n        ValLen() uint16\r\n    }\r\n    type ByteRecord []byte\r\n         \r\nActual public methods :\r\n\r\n* put : append the record at the offset given by `Page.use()` value\r\n* get : read in reverse way, starting from the end and iterating until the key is found, or the beginning\r\n\r\nThis design allows updating values for a given key without doing lookup before inserting (put is O(1) if the Page is not full). When the Page is full, the `Directory.split()` method skips the old values of the same key and re-insert just the latest\r\n\r\n# How to start\r\n\r\n## Get the package\r\n\r\n    go get github.com/BenJoyenConseil/bluckdb\r\n\r\nIf you run a go program for the first time, do not forget to setup your GOPATH : export GOPATH=$HOME/Dev/go\r\n\r\n## Run the server\r\n\r\n    go run server.go\r\n\r\nIt runs an httpserver with an instance of MmapKVStore which opens/creates the datafile on the /tmp/bluck.data path. \r\n\r\nNote : the path will change in the futur.\r\n\r\n## Benchmarks\r\n    \r\n    BenchmarkBluckDBPut                    1000000\t            1359 ns/op   -> 1,3 µs\r\n    BenchmarkBluckDBGet                    1000000\t            1406 ns/op   -> 1,4 µs\r\n    BenchmarkPutNaiveDiskKVStore-4          200000              6250 ns/op   -> 6,2 µs\r\n    BenchmarkGetNaiveDiskKVStore-4              30          44017416 ns/op   ->  44 ms\r\n    BenchmarkPutHashMap-4                  1000000              1385 ns/op   -> 1,3 µs\r\n    BenchmarkGetHashMap-4                  2000000               711 ns/op   -> 0,7 µs\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}